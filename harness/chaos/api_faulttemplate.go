/*
 * Chaos Manager
 *
 * ChaosManager serves as the primary API server for the chaos module, responsible for transferring and handling requests to their respective operations
 *
 * API version: 1.72.9
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package chaos

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type FaulttemplateApiService service

/*
FaulttemplateApiService Get the difference between 2 revisions of a fault template
Get the difference between 2 revisions of a fault template in a hub
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier account id that want to access the resource
 * @param organizationIdentifier organization id that want to access the resource
 * @param projectIdentifier project id that want to access the resource
 * @param hubIdentity reference of the hub i.e. hub ID
 * @param identity identity of the fault
 * @param revision1 1st revision of the fault template
 * @param revision2 2nd revision of the fault template
 * @param optional nil or *FaulttemplateApiCompareFaultTemplateRevisionsOpts - Optional Parameters:
     * @param "CorrelationID" (optional.String) -  correlation id is used to debug micro svc communication
@return ChaosfaulttemplateCompareRevisions
*/

type FaulttemplateApiCompareFaultTemplateRevisionsOpts struct {
	CorrelationID optional.String
}

func (a *FaulttemplateApiService) CompareFaultTemplateRevisions(ctx context.Context, accountIdentifier string, organizationIdentifier string, projectIdentifier string, hubIdentity string, identity string, revision1 string, revision2 string, localVarOptionals *FaulttemplateApiCompareFaultTemplateRevisionsOpts) (ChaosfaulttemplateCompareRevisions, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ChaosfaulttemplateCompareRevisions
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/rest/faulttemplates/{identity}/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"identity"+"}", fmt.Sprintf("%v", identity), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("organizationIdentifier", parameterToString(organizationIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("hubIdentity", parameterToString(hubIdentity, ""))
	if localVarOptionals != nil && localVarOptionals.CorrelationID.IsSet() {
		localVarQueryParams.Add("correlationID", parameterToString(localVarOptionals.CorrelationID.Value(), ""))
	}
	localVarQueryParams.Add("revision1", parameterToString(revision1, ""))
	localVarQueryParams.Add("revision2", parameterToString(revision2, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ChaosfaulttemplateCompareRevisions
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FaulttemplateApiService Create fault templates in a hub based on tag
Create fault templates in a hub based on tag
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body create fault request
 * @param accountIdentifier account id that want to access the resource
 * @param organizationIdentifier organization id that want to access the resource
 * @param projectIdentifier project id that want to access the resource
 * @param hubIdentity chaos hub identity
 * @param optional nil or *FaulttemplateApiCreateFaultTemplateOpts - Optional Parameters:
     * @param "CorrelationID" (optional.String) -  correlation id is used to debug micro svc communication
@return ChaosfaulttemplateCreateFaultTemplateResponse
*/

type FaulttemplateApiCreateFaultTemplateOpts struct {
	CorrelationID optional.String
}

func (a *FaulttemplateApiService) CreateFaultTemplate(ctx context.Context, body ChaosfaulttemplateCreateFaultTemplateRequest, accountIdentifier string, organizationIdentifier string, projectIdentifier string, hubIdentity string, localVarOptionals *FaulttemplateApiCreateFaultTemplateOpts) (ChaosfaulttemplateCreateFaultTemplateResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ChaosfaulttemplateCreateFaultTemplateResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/rest/faulttemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("organizationIdentifier", parameterToString(organizationIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("hubIdentity", parameterToString(hubIdentity, ""))
	if localVarOptionals != nil && localVarOptionals.CorrelationID.IsSet() {
		localVarQueryParams.Add("correlationID", parameterToString(localVarOptionals.CorrelationID.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ChaosfaulttemplateCreateFaultTemplateResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FaulttemplateApiService Delete the fault templates in a hub based on tag
Delete the fault templates in a hub based on tag
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier account id that want to access the resource
 * @param organizationIdentifier organization id that want to access the resource
 * @param projectIdentifier project id that want to access the resource
 * @param hubIdentity chaos hub identity
 * @param identity identity of the fault
 * @param optional nil or *FaulttemplateApiDeleteFaultTemplateOpts - Optional Parameters:
     * @param "CorrelationID" (optional.String) -  correlation id is used to debug micro svc communication
@return GithubComHarnessHceSaasGraphqlServerApiEmpty
*/

type FaulttemplateApiDeleteFaultTemplateOpts struct {
	CorrelationID optional.String
}

func (a *FaulttemplateApiService) DeleteFaultTemplate(ctx context.Context, accountIdentifier string, organizationIdentifier string, projectIdentifier string, hubIdentity string, identity string, localVarOptionals *FaulttemplateApiDeleteFaultTemplateOpts) (GithubComHarnessHceSaasGraphqlServerApiEmpty, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GithubComHarnessHceSaasGraphqlServerApiEmpty
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/rest/faulttemplates/{identity}"
	localVarPath = strings.Replace(localVarPath, "{"+"identity"+"}", fmt.Sprintf("%v", identity), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("organizationIdentifier", parameterToString(organizationIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("hubIdentity", parameterToString(hubIdentity, ""))
	if localVarOptionals != nil && localVarOptionals.CorrelationID.IsSet() {
		localVarQueryParams.Add("correlationID", parameterToString(localVarOptionals.CorrelationID.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GithubComHarnessHceSaasGraphqlServerApiEmpty
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FaulttemplateApiService Lists all the fault templates in a hub based on tag
Lists all the fault templates in a hub based on tag
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier account id that want to access the resource
 * @param organizationIdentifier organization id that want to access the resource
 * @param projectIdentifier project id that want to access the resource
 * @param hubIdentity chaos hub identity
 * @param revision revision of the 1st fault template
 * @param identity identity of the fault
 * @param optional nil or *FaulttemplateApiGetFaultTemplateOpts - Optional Parameters:
     * @param "CorrelationID" (optional.String) -  correlation id is used to debug micro svc communication
@return ChaosfaulttemplateGetFaultTemplateResponse
*/

type FaulttemplateApiGetFaultTemplateOpts struct {
	CorrelationID optional.String
}

func (a *FaulttemplateApiService) GetFaultTemplate(ctx context.Context, accountIdentifier string, organizationIdentifier string, projectIdentifier string, hubIdentity string, revision string, identity string, localVarOptionals *FaulttemplateApiGetFaultTemplateOpts) (ChaosfaulttemplateGetFaultTemplateResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ChaosfaulttemplateGetFaultTemplateResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/rest/faulttemplates/{identity}"
	localVarPath = strings.Replace(localVarPath, "{"+"identity"+"}", fmt.Sprintf("%v", identity), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("organizationIdentifier", parameterToString(organizationIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("hubIdentity", parameterToString(hubIdentity, ""))
	if localVarOptionals != nil && localVarOptionals.CorrelationID.IsSet() {
		localVarQueryParams.Add("correlationID", parameterToString(localVarOptionals.CorrelationID.Value(), ""))
	}
	localVarQueryParams.Add("revision", parameterToString(revision, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ChaosfaulttemplateGetFaultTemplateResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FaulttemplateApiService Lists all the revision of a fault template in a hub
Lists all the revision of a fault template in a hub
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier account id that want to access the resource
 * @param organizationIdentifier organization id that want to access the resource
 * @param projectIdentifier project id that want to access the resource
 * @param hubIdentity chaos hub identity
 * @param identity identity of the fault
 * @param page page number
 * @param limit limit per page
 * @param optional nil or *FaulttemplateApiGetFaultTemplateRevisionsOpts - Optional Parameters:
     * @param "CorrelationID" (optional.String) -  correlation id is used to debug micro svc communication
@return ChaosfaulttemplateListFaultTemplateResponse
*/

type FaulttemplateApiGetFaultTemplateRevisionsOpts struct {
	CorrelationID optional.String
}

func (a *FaulttemplateApiService) GetFaultTemplateRevisions(ctx context.Context, accountIdentifier string, organizationIdentifier string, projectIdentifier string, hubIdentity string, identity string, page int32, limit int32, localVarOptionals *FaulttemplateApiGetFaultTemplateRevisionsOpts) (ChaosfaulttemplateListFaultTemplateResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ChaosfaulttemplateListFaultTemplateResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/rest/faulttemplates/{identity}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"identity"+"}", fmt.Sprintf("%v", identity), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("organizationIdentifier", parameterToString(organizationIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("hubIdentity", parameterToString(hubIdentity, ""))
	if localVarOptionals != nil && localVarOptionals.CorrelationID.IsSet() {
		localVarQueryParams.Add("correlationID", parameterToString(localVarOptionals.CorrelationID.Value(), ""))
	}
	localVarQueryParams.Add("page", parameterToString(page, ""))
	localVarQueryParams.Add("limit", parameterToString(limit, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ChaosfaulttemplateListFaultTemplateResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FaulttemplateApiService Get the list of variables in a fault template
Get the list of variables in a fault template based on revision
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier account id that want to access the resource
 * @param organizationIdentifier organization id that want to access the resource
 * @param projectIdentifier project id that want to access the resource
 * @param hubIdentity reference of the hub i.e. hub ID
 * @param identity identity of the fault
 * @param revision revision of the 1st fault template
 * @param optional nil or *FaulttemplateApiGetFaultTemplateVariablesOpts - Optional Parameters:
     * @param "CorrelationID" (optional.String) -  correlation id is used to debug micro svc communication
@return ChaosfaulttemplateFaultTemplateVariables
*/

type FaulttemplateApiGetFaultTemplateVariablesOpts struct {
	CorrelationID optional.String
}

func (a *FaulttemplateApiService) GetFaultTemplateVariables(ctx context.Context, accountIdentifier string, organizationIdentifier string, projectIdentifier string, hubIdentity string, identity string, revision string, localVarOptionals *FaulttemplateApiGetFaultTemplateVariablesOpts) (ChaosfaulttemplateFaultTemplateVariables, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ChaosfaulttemplateFaultTemplateVariables
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/rest/faulttemplates/{identity}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"identity"+"}", fmt.Sprintf("%v", identity), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("organizationIdentifier", parameterToString(organizationIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("hubIdentity", parameterToString(hubIdentity, ""))
	if localVarOptionals != nil && localVarOptionals.CorrelationID.IsSet() {
		localVarQueryParams.Add("correlationID", parameterToString(localVarOptionals.CorrelationID.Value(), ""))
	}
	localVarQueryParams.Add("revision", parameterToString(revision, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ChaosfaulttemplateFaultTemplateVariables
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FaulttemplateApiService Get the list of variables in a fault template
Get the list of variables in a fault template based on revision
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier account id that want to access the resource
 * @param organizationIdentifier organization id that want to access the resource
 * @param projectIdentifier project id that want to access the resource
 * @param hubIdentity reference of the hub i.e. hub ID
 * @param identity identity of the fault
 * @param revision revision of the 1st fault template
 * @param optional nil or *FaulttemplateApiGetFaultTemplateYamlOpts - Optional Parameters:
     * @param "CorrelationID" (optional.String) -  correlation id is used to debug micro svc communication
@return ChaosfaulttemplateFaultTemplateYaml
*/

type FaulttemplateApiGetFaultTemplateYamlOpts struct {
	CorrelationID optional.String
}

func (a *FaulttemplateApiService) GetFaultTemplateYaml(ctx context.Context, accountIdentifier string, organizationIdentifier string, projectIdentifier string, hubIdentity string, identity string, revision string, localVarOptionals *FaulttemplateApiGetFaultTemplateYamlOpts) (ChaosfaulttemplateFaultTemplateYaml, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ChaosfaulttemplateFaultTemplateYaml
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/rest/faulttemplates/{identity}/yaml"
	localVarPath = strings.Replace(localVarPath, "{"+"identity"+"}", fmt.Sprintf("%v", identity), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("organizationIdentifier", parameterToString(organizationIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("hubIdentity", parameterToString(hubIdentity, ""))
	if localVarOptionals != nil && localVarOptionals.CorrelationID.IsSet() {
		localVarQueryParams.Add("correlationID", parameterToString(localVarOptionals.CorrelationID.Value(), ""))
	}
	localVarQueryParams.Add("revision", parameterToString(revision, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ChaosfaulttemplateFaultTemplateYaml
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FaulttemplateApiService Lists all the fault templates in a hub based on tag
Lists all the fault templates in a hub based on tag
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier account id to access the resource
 * @param optional nil or *FaulttemplateApiListFaultTemplateOpts - Optional Parameters:
     * @param "Category" (optional.String) -
     * @param "CorrelationID" (optional.String) -  correlation id is used to debug micro svc communication
     * @param "HubIdentity" (optional.String) -  hub identity used for filter
     * @param "IncludeAllScope" (optional.Bool) -
     * @param "Infrastructure" (optional.String) -  infrastructure used for filter
     * @param "InfrastructureType" (optional.String) -  infrastructure type used for filter
     * @param "IsEnterprise" (optional.Bool) -  if this fault is enterprise fault or not
     * @param "Limit" (optional.Int32) -
     * @param "OrganizationIdentifier" (optional.String) -  organization id to access the resource
     * @param "Page" (optional.Int32) -
     * @param "PermissionsRequired" (optional.String) -  permissions required for filter
     * @param "ProjectIdentifier" (optional.String) -  project id to access the resource
     * @param "Search" (optional.String) -  name that you want to search
     * @param "SortAscending" (optional.Bool) -  if sort order ascending or not
     * @param "SortField" (optional.String) -  field  name that you want to sort
     * @param "Tags" (optional.String) -  comma separated tags used for filter
     * @param "Type_" (optional.String) -  type of the fault used for filter
@return ChaosfaulttemplateListFaultTemplateResponse
*/

type FaulttemplateApiListFaultTemplateOpts struct {
	Category               optional.String
	CorrelationID          optional.String
	HubIdentity            optional.String
	IncludeAllScope        optional.Bool
	Infrastructure         optional.String
	InfrastructureType     optional.String
	IsEnterprise           optional.Bool
	Limit                  optional.Int32
	OrganizationIdentifier optional.String
	Page                   optional.Int32
	PermissionsRequired    optional.String
	ProjectIdentifier      optional.String
	Search                 optional.String
	SortAscending          optional.Bool
	SortField              optional.String
	Tags                   optional.String
	Type_                  optional.String
}

func (a *FaulttemplateApiService) ListFaultTemplate(ctx context.Context, accountIdentifier string, localVarOptionals *FaulttemplateApiListFaultTemplateOpts) (ChaosfaulttemplateListFaultTemplateResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ChaosfaulttemplateListFaultTemplateResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/rest/faulttemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarQueryParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CorrelationID.IsSet() {
		localVarQueryParams.Add("correlationID", parameterToString(localVarOptionals.CorrelationID.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HubIdentity.IsSet() {
		localVarQueryParams.Add("hubIdentity", parameterToString(localVarOptionals.HubIdentity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeAllScope.IsSet() {
		localVarQueryParams.Add("includeAllScope", parameterToString(localVarOptionals.IncludeAllScope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Infrastructure.IsSet() {
		localVarQueryParams.Add("infrastructure", parameterToString(localVarOptionals.Infrastructure.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InfrastructureType.IsSet() {
		localVarQueryParams.Add("infrastructureType", parameterToString(localVarOptionals.InfrastructureType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsEnterprise.IsSet() {
		localVarQueryParams.Add("isEnterprise", parameterToString(localVarOptionals.IsEnterprise.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrganizationIdentifier.IsSet() {
		localVarQueryParams.Add("organizationIdentifier", parameterToString(localVarOptionals.OrganizationIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PermissionsRequired.IsSet() {
		localVarQueryParams.Add("permissionsRequired", parameterToString(localVarOptionals.PermissionsRequired.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Search.IsSet() {
		localVarQueryParams.Add("search", parameterToString(localVarOptionals.Search.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SortAscending.IsSet() {
		localVarQueryParams.Add("sortAscending", parameterToString(localVarOptionals.SortAscending.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SortField.IsSet() {
		localVarQueryParams.Add("sortField", parameterToString(localVarOptionals.SortField.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ChaosfaulttemplateListFaultTemplateResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FaulttemplateApiService Update the fault templates in a hub based on tag
Update the fault templates in a hub based on tag
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier account id that want to access the resource
 * @param organizationIdentifier organization id that want to access the resource
 * @param projectIdentifier project id that want to access the resource
 * @param hubIdentity chaos hub identity
 * @param identity identity of the fault
 * @param optional nil or *FaulttemplateApiUpdateFaultTemplateOpts - Optional Parameters:
     * @param "CorrelationID" (optional.String) -  correlation id is used to debug micro svc communication
@return ChaosfaulttemplateUpdateFaultTemplateResponse
*/

type FaulttemplateApiUpdateFaultTemplateOpts struct {
	CorrelationID optional.String
}

func (a *FaulttemplateApiService) UpdateFaultTemplate(ctx context.Context, accountIdentifier string, organizationIdentifier string, projectIdentifier string, hubIdentity string, identity string, localVarOptionals *FaulttemplateApiUpdateFaultTemplateOpts) (ChaosfaulttemplateUpdateFaultTemplateResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ChaosfaulttemplateUpdateFaultTemplateResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/rest/faulttemplates/{identity}"
	localVarPath = strings.Replace(localVarPath, "{"+"identity"+"}", fmt.Sprintf("%v", identity), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("organizationIdentifier", parameterToString(organizationIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("hubIdentity", parameterToString(hubIdentity, ""))
	if localVarOptionals != nil && localVarOptionals.CorrelationID.IsSet() {
		localVarQueryParams.Add("correlationID", parameterToString(localVarOptionals.CorrelationID.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ChaosfaulttemplateUpdateFaultTemplateResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ApiRestError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
