/*
 * Harness NextGen Software Delivery Platform API Reference
 *
 * This is the Open Api Spec 3 for the NextGen Manager. This is under active development. Beware of the breaking change with respect to the generated code stub
 *
 * API version: 3.0
 * Contact: contact@harness.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package nextgen

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type RepositoriesApiService service

/*
RepositoriesApiService CreateRepository creates a new repository configuration
CreateRepository creates a new repository configuration.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param agentIdentifier Agent identifier for entity.
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceCreateRepositoryOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "Identifier" (optional.String) -
     * @param "RepoCredsId" (optional.String) -
@return Servicev1Repository
*/

type RepositoriesApiAgentRepositoryServiceCreateRepositoryOpts struct {
	AccountIdentifier optional.String
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
	Identifier        optional.String
	RepoCredsId       optional.String
}

func (a *RepositoriesApiService) AgentRepositoryServiceCreateRepository(ctx context.Context, body RepositoriesRepoCreateRequest, agentIdentifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceCreateRepositoryOpts) (Servicev1Repository, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Repository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Identifier.IsSet() {
		localVarQueryParams.Add("identifier", parameterToString(localVarOptionals.Identifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoCredsId.IsSet() {
		localVarQueryParams.Add("repoCredsId", parameterToString(localVarOptionals.RepoCredsId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Repository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService DeleteRepository deletes a repository from the configuration
DeleteRepository deletes a repository from the configuration.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param identifier
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceDeleteRepositoryOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "QueryRepo" (optional.String) -  Repo URL for query.
     * @param "QueryForceRefresh" (optional.Bool) -  Whether to force a cache refresh on repo&#x27;s connection state.
     * @param "QueryProject" (optional.String) -  The associated project project.
     * @param "ForceDelete" (optional.Bool) -
@return RepositoriesRepoResponse
*/

type RepositoriesApiAgentRepositoryServiceDeleteRepositoryOpts struct {
	AccountIdentifier optional.String
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
	QueryRepo         optional.String
	QueryForceRefresh optional.Bool
	QueryProject      optional.String
	ForceDelete       optional.Bool
}

func (a *RepositoriesApiService) AgentRepositoryServiceDeleteRepository(ctx context.Context, agentIdentifier string, identifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceDeleteRepositoryOpts) (RepositoriesRepoResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesRepoResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryForceRefresh.IsSet() {
		localVarQueryParams.Add("query.forceRefresh", parameterToString(localVarOptionals.QueryForceRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForceDelete.IsSet() {
		localVarQueryParams.Add("forceDelete", parameterToString(localVarOptionals.ForceDelete.Value(), ""))
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesRepoResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService Get returns a repository or its credentials
Get returns a repository or its credentials.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param identifier
 * @param accountIdentifier Account Identifier for the Entity.
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceGetOpts - Optional Parameters:
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "QueryRepo" (optional.String) -  Repo URL for query.
     * @param "QueryForceRefresh" (optional.Bool) -  Whether to force a cache refresh on repo&#x27;s connection state.
     * @param "QueryProject" (optional.String) -  The associated project project.
@return Servicev1Repository
*/

type RepositoriesApiAgentRepositoryServiceGetOpts struct {
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
	QueryRepo         optional.String
	QueryForceRefresh optional.Bool
	QueryProject      optional.String
}

func (a *RepositoriesApiService) AgentRepositoryServiceGet(ctx context.Context, agentIdentifier string, identifier string, accountIdentifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceGetOpts) (Servicev1Repository, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Repository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryForceRefresh.IsSet() {
		localVarQueryParams.Add("query.forceRefresh", parameterToString(localVarOptionals.QueryForceRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Repository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService GetAppDetails returns application details by given path
GetAppDetails returns application details by given path.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param identifier
 * @param accountIdentifier Account Identifier for the Entity.
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceGetAppDetailsOpts - Optional Parameters:
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "QuerySourceRepoURL" (optional.String) -  RepoURL is the URL to the repository (Git or Helm) that contains the application manifests.
     * @param "QuerySourcePath" (optional.String) -  Path is a directory path within the Git repository, and is only valid for applications sourced from Git.
     * @param "QuerySourceTargetRevision" (optional.String) -  TargetRevision defines the revision of the source to sync the application to. In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag for the Chart&#x27;s version.
     * @param "QuerySourceHelmValueFiles" (optional.Interface of []string) -  ValuesFiles is a list of Helm value files to use when generating a template.
     * @param "QuerySourceHelmReleaseName" (optional.String) -  ReleaseName is the Helm release name to use. If omitted it will use the application name.
     * @param "QuerySourceHelmValues" (optional.String) -  Values specifies Helm values to be passed to helm template, typically defined as a block.
     * @param "QuerySourceHelmVersion" (optional.String) -  Version is the Helm version to use for templating (either \&quot;2\&quot; or \&quot;3\&quot;).
     * @param "QuerySourceHelmPassCredentials" (optional.Bool) -  PassCredentials pass credentials to all domains (Helm&#x27;s --pass-credentials).
     * @param "QuerySourceHelmIgnoreMissingValueFiles" (optional.Bool) -  IgnoreMissingValueFiles prevents helm template from failing when valueFiles do not exist locally by not appending them to helm template --values.
     * @param "QuerySourceHelmSkipCrds" (optional.Bool) -  SkipCrds skips custom resource definition installation step (Helm&#x27;s --skip-crds).
     * @param "QuerySourceHelmValuesObjectRaw" (optional.String) -  Raw is the underlying serialization of this object.  TODO: Determine how to detect ContentType and ContentEncoding of &#x27;Raw&#x27; data.
     * @param "QuerySourceHelmNamespace" (optional.String) -  Namespace is an optional namespace to template with. If left empty, defaults to the app&#x27;s destination namespace.
     * @param "QuerySourceHelmKubeVersion" (optional.String) -  KubeVersion specifies the Kubernetes API version to pass to Helm when templating manifests. By default, Argo CD uses the Kubernetes version of the target cluster.
     * @param "QuerySourceHelmApiVersions" (optional.Interface of []string) -  APIVersions specifies the Kubernetes resource API versions to pass to Helm when templating manifests. By default, Argo CD uses the API versions of the target cluster. The format is [group/]version/kind.
     * @param "QuerySourceHelmSkipTests" (optional.Bool) -  SkipTests skips test manifest installation step (Helm&#x27;s --skip-tests).
     * @param "QuerySourceHelmSkipSchemaValidation" (optional.Bool) -  SkipSchemaValidation skips JSON schema validation (Helm&#x27;s --skip-schema-validation).
     * @param "QuerySourceKustomizeNamePrefix" (optional.String) -  NamePrefix is a prefix appended to resources for Kustomize apps.
     * @param "QuerySourceKustomizeNameSuffix" (optional.String) -  NameSuffix is a suffix appended to resources for Kustomize apps.
     * @param "QuerySourceKustomizeImages" (optional.Interface of []string) -  Images is a list of Kustomize image override specifications.
     * @param "QuerySourceKustomizeVersion" (optional.String) -  Version controls which version of Kustomize to use for rendering manifests.
     * @param "QuerySourceKustomizeForceCommonLabels" (optional.Bool) -  ForceCommonLabels specifies whether to force applying common labels to resources for Kustomize apps.
     * @param "QuerySourceKustomizeForceCommonAnnotations" (optional.Bool) -  ForceCommonAnnotations specifies whether to force applying common annotations to resources for Kustomize apps.
     * @param "QuerySourceKustomizeNamespace" (optional.String) -  Namespace sets the namespace that Kustomize adds to all resources.
     * @param "QuerySourceKustomizeComponents" (optional.Interface of []string) -  Components specifies a list of kustomize components to add to the kustomization before building.
     * @param "QuerySourceKustomizeLabelWithoutSelector" (optional.Bool) -  LabelWithoutSelector specifies whether to apply common labels to resource selectors or not.
     * @param "QuerySourceKustomizeKubeVersion" (optional.String) -  KubeVersion specifies the Kubernetes API version to pass to Helm when templating manifests. By default, Argo CD uses the Kubernetes version of the target cluster.
     * @param "QuerySourceKustomizeApiVersions" (optional.Interface of []string) -  APIVersions specifies the Kubernetes resource API versions to pass to Helm when templating manifests. By default, Argo CD uses the API versions of the target cluster. The format is [group/]version/kind.
     * @param "QuerySourceKsonnetEnvironment" (optional.String) -  Environment is a ksonnet application environment name.
     * @param "QuerySourceDirectoryRecurse" (optional.Bool) -  Recurse specifies whether to scan a directory recursively for manifests.
     * @param "QuerySourceDirectoryJsonnetLibs" (optional.Interface of []string) -  Additional library search dirs.
     * @param "QuerySourceDirectoryExclude" (optional.String) -  Exclude contains a glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
     * @param "QuerySourceDirectoryInclude" (optional.String) -  Include contains a glob pattern to match paths against that should be explicitly included during manifest generation.
     * @param "QuerySourcePluginName" (optional.String) -
     * @param "QuerySourceChart" (optional.String) -  Chart is a Helm chart name, and must be specified for applications sourced from a Helm repo.
     * @param "QuerySourceRef" (optional.String) -  Ref is reference to another source within sources field. This field will not be used if used with a &#x60;source&#x60; tag.
     * @param "QuerySourceName" (optional.String) -  Name is used to refer to a source and is displayed in the UI. It is used in multi-source Applications.
     * @param "QueryAppName" (optional.String) -
     * @param "QueryAppProject" (optional.String) -
     * @param "QuerySourceIndex" (optional.Int32) -  source index (for multi source apps).
     * @param "QueryVersionId" (optional.Int32) -  versionId from historical data (for multi source apps).
@return RepositoriesRepoAppDetailsResponse
*/

type RepositoriesApiAgentRepositoryServiceGetAppDetailsOpts struct {
	OrgIdentifier                              optional.String
	ProjectIdentifier                          optional.String
	QuerySourceRepoURL                         optional.String
	QuerySourcePath                            optional.String
	QuerySourceTargetRevision                  optional.String
	QuerySourceHelmValueFiles                  optional.Interface
	QuerySourceHelmReleaseName                 optional.String
	QuerySourceHelmValues                      optional.String
	QuerySourceHelmVersion                     optional.String
	QuerySourceHelmPassCredentials             optional.Bool
	QuerySourceHelmIgnoreMissingValueFiles     optional.Bool
	QuerySourceHelmSkipCrds                    optional.Bool
	QuerySourceHelmValuesObjectRaw             optional.String
	QuerySourceHelmNamespace                   optional.String
	QuerySourceHelmKubeVersion                 optional.String
	QuerySourceHelmApiVersions                 optional.Interface
	QuerySourceHelmSkipTests                   optional.Bool
	QuerySourceHelmSkipSchemaValidation        optional.Bool
	QuerySourceKustomizeNamePrefix             optional.String
	QuerySourceKustomizeNameSuffix             optional.String
	QuerySourceKustomizeImages                 optional.Interface
	QuerySourceKustomizeVersion                optional.String
	QuerySourceKustomizeForceCommonLabels      optional.Bool
	QuerySourceKustomizeForceCommonAnnotations optional.Bool
	QuerySourceKustomizeNamespace              optional.String
	QuerySourceKustomizeComponents             optional.Interface
	QuerySourceKustomizeLabelWithoutSelector   optional.Bool
	QuerySourceKustomizeKubeVersion            optional.String
	QuerySourceKustomizeApiVersions            optional.Interface
	QuerySourceKsonnetEnvironment              optional.String
	QuerySourceDirectoryRecurse                optional.Bool
	QuerySourceDirectoryJsonnetLibs            optional.Interface
	QuerySourceDirectoryExclude                optional.String
	QuerySourceDirectoryInclude                optional.String
	QuerySourcePluginName                      optional.String
	QuerySourceChart                           optional.String
	QuerySourceRef                             optional.String
	QuerySourceName                            optional.String
	QueryAppName                               optional.String
	QueryAppProject                            optional.String
	QuerySourceIndex                           optional.Int32
	QueryVersionId                             optional.Int32
}

func (a *RepositoriesApiService) AgentRepositoryServiceGetAppDetails(ctx context.Context, agentIdentifier string, identifier string, accountIdentifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceGetAppDetailsOpts) (RepositoriesRepoAppDetailsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesRepoAppDetailsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories/{identifier}/appdetails"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceRepoURL.IsSet() {
		localVarQueryParams.Add("query.source.repoURL", parameterToString(localVarOptionals.QuerySourceRepoURL.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourcePath.IsSet() {
		localVarQueryParams.Add("query.source.path", parameterToString(localVarOptionals.QuerySourcePath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceTargetRevision.IsSet() {
		localVarQueryParams.Add("query.source.targetRevision", parameterToString(localVarOptionals.QuerySourceTargetRevision.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmValueFiles.IsSet() {
		addQueryParam(localVarQueryParams, "query.source.helm.valueFiles", localVarOptionals.QuerySourceHelmValueFiles.Value(), "multi")
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmReleaseName.IsSet() {
		localVarQueryParams.Add("query.source.helm.releaseName", parameterToString(localVarOptionals.QuerySourceHelmReleaseName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmValues.IsSet() {
		localVarQueryParams.Add("query.source.helm.values", parameterToString(localVarOptionals.QuerySourceHelmValues.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmVersion.IsSet() {
		localVarQueryParams.Add("query.source.helm.version", parameterToString(localVarOptionals.QuerySourceHelmVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmPassCredentials.IsSet() {
		localVarQueryParams.Add("query.source.helm.passCredentials", parameterToString(localVarOptionals.QuerySourceHelmPassCredentials.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmIgnoreMissingValueFiles.IsSet() {
		localVarQueryParams.Add("query.source.helm.ignoreMissingValueFiles", parameterToString(localVarOptionals.QuerySourceHelmIgnoreMissingValueFiles.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmSkipCrds.IsSet() {
		localVarQueryParams.Add("query.source.helm.skipCrds", parameterToString(localVarOptionals.QuerySourceHelmSkipCrds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmValuesObjectRaw.IsSet() {
		localVarQueryParams.Add("query.source.helm.valuesObject.raw", parameterToString(localVarOptionals.QuerySourceHelmValuesObjectRaw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmNamespace.IsSet() {
		localVarQueryParams.Add("query.source.helm.namespace", parameterToString(localVarOptionals.QuerySourceHelmNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmKubeVersion.IsSet() {
		localVarQueryParams.Add("query.source.helm.kubeVersion", parameterToString(localVarOptionals.QuerySourceHelmKubeVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmApiVersions.IsSet() {
		addQueryParam(localVarQueryParams, "query.source.helm.apiVersions", localVarOptionals.QuerySourceHelmApiVersions.Value(), "multi")
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmSkipTests.IsSet() {
		localVarQueryParams.Add("query.source.helm.skipTests", parameterToString(localVarOptionals.QuerySourceHelmSkipTests.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceHelmSkipSchemaValidation.IsSet() {
		localVarQueryParams.Add("query.source.helm.skipSchemaValidation", parameterToString(localVarOptionals.QuerySourceHelmSkipSchemaValidation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeNamePrefix.IsSet() {
		localVarQueryParams.Add("query.source.kustomize.namePrefix", parameterToString(localVarOptionals.QuerySourceKustomizeNamePrefix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeNameSuffix.IsSet() {
		localVarQueryParams.Add("query.source.kustomize.nameSuffix", parameterToString(localVarOptionals.QuerySourceKustomizeNameSuffix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeImages.IsSet() {
		addQueryParam(localVarQueryParams, "query.source.kustomize.images", localVarOptionals.QuerySourceKustomizeImages.Value(), "multi")
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeVersion.IsSet() {
		localVarQueryParams.Add("query.source.kustomize.version", parameterToString(localVarOptionals.QuerySourceKustomizeVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeForceCommonLabels.IsSet() {
		localVarQueryParams.Add("query.source.kustomize.forceCommonLabels", parameterToString(localVarOptionals.QuerySourceKustomizeForceCommonLabels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeForceCommonAnnotations.IsSet() {
		localVarQueryParams.Add("query.source.kustomize.forceCommonAnnotations", parameterToString(localVarOptionals.QuerySourceKustomizeForceCommonAnnotations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeNamespace.IsSet() {
		localVarQueryParams.Add("query.source.kustomize.namespace", parameterToString(localVarOptionals.QuerySourceKustomizeNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeComponents.IsSet() {
		addQueryParam(localVarQueryParams, "query.source.kustomize.components", localVarOptionals.QuerySourceKustomizeComponents.Value(), "multi")
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeLabelWithoutSelector.IsSet() {
		localVarQueryParams.Add("query.source.kustomize.labelWithoutSelector", parameterToString(localVarOptionals.QuerySourceKustomizeLabelWithoutSelector.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeKubeVersion.IsSet() {
		localVarQueryParams.Add("query.source.kustomize.kubeVersion", parameterToString(localVarOptionals.QuerySourceKustomizeKubeVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKustomizeApiVersions.IsSet() {
		addQueryParam(localVarQueryParams, "query.source.kustomize.apiVersions", localVarOptionals.QuerySourceKustomizeApiVersions.Value(), "multi")
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceKsonnetEnvironment.IsSet() {
		localVarQueryParams.Add("query.source.ksonnet.environment", parameterToString(localVarOptionals.QuerySourceKsonnetEnvironment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceDirectoryRecurse.IsSet() {
		localVarQueryParams.Add("query.source.directory.recurse", parameterToString(localVarOptionals.QuerySourceDirectoryRecurse.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceDirectoryJsonnetLibs.IsSet() {
		addQueryParam(localVarQueryParams, "query.source.directory.jsonnet.libs", localVarOptionals.QuerySourceDirectoryJsonnetLibs.Value(), "multi")
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceDirectoryExclude.IsSet() {
		localVarQueryParams.Add("query.source.directory.exclude", parameterToString(localVarOptionals.QuerySourceDirectoryExclude.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceDirectoryInclude.IsSet() {
		localVarQueryParams.Add("query.source.directory.include", parameterToString(localVarOptionals.QuerySourceDirectoryInclude.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourcePluginName.IsSet() {
		localVarQueryParams.Add("query.source.plugin.name", parameterToString(localVarOptionals.QuerySourcePluginName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceChart.IsSet() {
		localVarQueryParams.Add("query.source.chart", parameterToString(localVarOptionals.QuerySourceChart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceRef.IsSet() {
		localVarQueryParams.Add("query.source.ref", parameterToString(localVarOptionals.QuerySourceRef.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceName.IsSet() {
		localVarQueryParams.Add("query.source.name", parameterToString(localVarOptionals.QuerySourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppName.IsSet() {
		localVarQueryParams.Add("query.appName", parameterToString(localVarOptionals.QueryAppName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppProject.IsSet() {
		localVarQueryParams.Add("query.appProject", parameterToString(localVarOptionals.QueryAppProject.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySourceIndex.IsSet() {
		localVarQueryParams.Add("query.sourceIndex", parameterToString(localVarOptionals.QuerySourceIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryVersionId.IsSet() {
		localVarQueryParams.Add("query.versionId", parameterToString(localVarOptionals.QueryVersionId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesRepoAppDetailsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService GetHelmCharts returns list of helm charts in the specified repository
GetHelmCharts returns list of helm charts in the specified repository.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param identifier
 * @param accountIdentifier Account Identifier for the Entity.
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceGetHelmChartsOpts - Optional Parameters:
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "QueryRepo" (optional.String) -  Repo URL for query.
     * @param "QueryForceRefresh" (optional.Bool) -  Whether to force a cache refresh on repo&#x27;s connection state.
     * @param "QueryProject" (optional.String) -  The associated project project.
@return RepositoriesHelmChartsResponse
*/

type RepositoriesApiAgentRepositoryServiceGetHelmChartsOpts struct {
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
	QueryRepo         optional.String
	QueryForceRefresh optional.Bool
	QueryProject      optional.String
}

func (a *RepositoriesApiService) AgentRepositoryServiceGetHelmCharts(ctx context.Context, agentIdentifier string, identifier string, accountIdentifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceGetHelmChartsOpts) (RepositoriesHelmChartsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesHelmChartsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories/{identifier}/helmcharts"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryForceRefresh.IsSet() {
		localVarQueryParams.Add("query.forceRefresh", parameterToString(localVarOptionals.QueryForceRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesHelmChartsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService ListApps returns list of apps in the repo
ListApps returns list of apps in the repo.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param identifier
 * @param accountIdentifier Account Identifier for the Entity.
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceListAppsOpts - Optional Parameters:
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "QueryRepo" (optional.String) -
     * @param "QueryRevision" (optional.String) -
     * @param "QueryAppName" (optional.String) -
     * @param "QueryAppProject" (optional.String) -
@return RepositoriesRepoAppsResponse
*/

type RepositoriesApiAgentRepositoryServiceListAppsOpts struct {
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
	QueryRepo         optional.String
	QueryRevision     optional.String
	QueryAppName      optional.String
	QueryAppProject   optional.String
}

func (a *RepositoriesApiService) AgentRepositoryServiceListApps(ctx context.Context, agentIdentifier string, identifier string, accountIdentifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceListAppsOpts) (RepositoriesRepoAppsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesRepoAppsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories/{identifier}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRevision.IsSet() {
		localVarQueryParams.Add("query.revision", parameterToString(localVarOptionals.QueryRevision.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppName.IsSet() {
		localVarQueryParams.Add("query.appName", parameterToString(localVarOptionals.QueryAppName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppProject.IsSet() {
		localVarQueryParams.Add("query.appProject", parameterToString(localVarOptionals.QueryAppProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesRepoAppsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService Returns a list of refs (e.g. branches and tags) in the repo
Returns a list of refs (e.g. branches and tags) in the repo.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param identifier
 * @param accountIdentifier Account Identifier for the Entity.
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceListRefsOpts - Optional Parameters:
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "QueryRepo" (optional.String) -  Repo URL for query.
     * @param "QueryForceRefresh" (optional.Bool) -  Whether to force a cache refresh on repo&#x27;s connection state.
     * @param "QueryProject" (optional.String) -  The associated project project.
@return RepositoriesRefs
*/

type RepositoriesApiAgentRepositoryServiceListRefsOpts struct {
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
	QueryRepo         optional.String
	QueryForceRefresh optional.Bool
	QueryProject      optional.String
}

func (a *RepositoriesApiService) AgentRepositoryServiceListRefs(ctx context.Context, agentIdentifier string, identifier string, accountIdentifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceListRefsOpts) (RepositoriesRefs, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesRefs
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories/{identifier}/refs"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryForceRefresh.IsSet() {
		localVarQueryParams.Add("query.forceRefresh", parameterToString(localVarOptionals.QueryForceRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesRefs
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService ListRepositories gets a list of all configured repositories
ListRepositories gets a list of all configured repositories.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param accountIdentifier Account Identifier for the Entity.
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceListRepositoriesOpts - Optional Parameters:
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "Identifier" (optional.String) -
     * @param "QueryRepo" (optional.String) -  Repo URL for query.
     * @param "QueryForceRefresh" (optional.Bool) -  Whether to force a cache refresh on repo&#x27;s connection state.
     * @param "QueryProject" (optional.String) -  The associated project project.
@return RepositoriesRepositoryList
*/

type RepositoriesApiAgentRepositoryServiceListRepositoriesOpts struct {
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
	Identifier        optional.String
	QueryRepo         optional.String
	QueryForceRefresh optional.Bool
	QueryProject      optional.String
}

func (a *RepositoriesApiService) AgentRepositoryServiceListRepositories(ctx context.Context, agentIdentifier string, accountIdentifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceListRepositoriesOpts) (RepositoriesRepositoryList, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesRepositoryList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Identifier.IsSet() {
		localVarQueryParams.Add("identifier", parameterToString(localVarOptionals.Identifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryForceRefresh.IsSet() {
		localVarQueryParams.Add("query.forceRefresh", parameterToString(localVarOptionals.QueryForceRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesRepositoryList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService UpdateRepository updates a repository configuration
UpdateRepository updates a repository configuration.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param agentIdentifier Agent identifier for entity.
 * @param identifier
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceUpdateRepositoryOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
@return Servicev1Repository
*/

type RepositoriesApiAgentRepositoryServiceUpdateRepositoryOpts struct {
	AccountIdentifier optional.String
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
}

func (a *RepositoriesApiService) AgentRepositoryServiceUpdateRepository(ctx context.Context, body RepositoriesRepoUpdateRequest, agentIdentifier string, identifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceUpdateRepositoryOpts) (Servicev1Repository, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Repository
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Repository
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService ValidateAccess gets connection state for a repository
ValidateAccess gets connection state for a repository.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param accountIdentifier Account Identifier for the Entity.
 * @param agentIdentifier Agent identifier for entity.
 * @param optional nil or *RepositoriesApiAgentRepositoryServiceValidateAccessOpts - Optional Parameters:
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "Identifier" (optional.String) -
@return CommonsConnectionState
*/

type RepositoriesApiAgentRepositoryServiceValidateAccessOpts struct {
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
	Identifier        optional.String
}

func (a *RepositoriesApiService) AgentRepositoryServiceValidateAccess(ctx context.Context, body RepositoriesRepoAccessQuery, accountIdentifier string, agentIdentifier string, localVarOptionals *RepositoriesApiAgentRepositoryServiceValidateAccessOpts) (CommonsConnectionState, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue CommonsConnectionState
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/repositories/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Identifier.IsSet() {
		localVarQueryParams.Add("identifier", parameterToString(localVarOptionals.Identifier.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v CommonsConnectionState
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService Checks whether a repository with the given name exists
Checks whether a repository with the given name exists.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountIdentifier Account Identifier for the Entity.
 * @param optional nil or *RepositoriesApiRepositoryServiceExistsOpts - Optional Parameters:
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "AgentIdentifier" (optional.String) -  Agent identifier for entity.
     * @param "Url" (optional.String) -
@return bool
*/

type RepositoriesApiRepositoryServiceExistsOpts struct {
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
	AgentIdentifier   optional.String
	Url               optional.String
}

func (a *RepositoriesApiService) RepositoryServiceExists(ctx context.Context, accountIdentifier string, localVarOptionals *RepositoriesApiRepositoryServiceExistsOpts) (bool, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue bool
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/repositories/exists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentIdentifier.IsSet() {
		localVarQueryParams.Add("agentIdentifier", parameterToString(localVarOptionals.AgentIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Url.IsSet() {
		localVarQueryParams.Add("url", parameterToString(localVarOptionals.Url.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v bool
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
RepositoriesApiService List returns list of Repositories
List returns list of Repositories
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body

@return V1Repositorylist
*/
func (a *RepositoriesApiService) RepositoryServiceListRepositories(ctx context.Context, body V1RepositoryQuery) (V1Repositorylist, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue V1Repositorylist
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/repositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v V1Repositorylist
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
