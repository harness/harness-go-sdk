/*
 * Harness NextGen Software Delivery Platform API Reference
 *
 * This is the Open Api Spec 3 for the NextGen Manager. This is under active development. Beware of the breaking change with respect to the generated code stub
 *
 * API version: 3.0
 * Contact: contact@harness.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package nextgen

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type ApplicationsApiService service

/*
ApplicationsApiService Create creates an application
Creates application in project.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param agentIdentifier Agent identifier for entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceCreateOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "ClusterIdentifier" (optional.String) -
     * @param "RepoIdentifier" (optional.String) -
     * @param "SkipRepoValidation" (optional.Bool) -
     * @param "RepoIdentifiers" (optional.Interface of []string) -
@return Servicev1Application
*/

type ApplicationsApiAgentApplicationServiceCreateOpts struct {
	AccountIdentifier  optional.String
	OrgIdentifier      optional.String
	ProjectIdentifier  optional.String
	ClusterIdentifier  optional.String
	RepoIdentifier     optional.String
	SkipRepoValidation optional.Bool
	RepoIdentifiers    optional.Interface
}

func (a *ApplicationsApiService) AgentApplicationServiceCreate(ctx context.Context, body ApplicationsApplicationCreateRequest, agentIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceCreateOpts) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterIdentifier.IsSet() {
		localVarQueryParams.Add("clusterIdentifier", parameterToString(localVarOptionals.ClusterIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SkipRepoValidation.IsSet() {
		localVarQueryParams.Add("skipRepoValidation", parameterToString(localVarOptionals.SkipRepoValidation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifiers.IsSet() {
		// cast RepoIdentifiers to array of string
		ids := localVarOptionals.RepoIdentifiers.Value().([]string)
		for _, id := range ids {
			localVarQueryParams.Add("repoIdentifiers", parameterToString(id, ""))
		}
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Delete deletes an application
Delete deletes an application.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServiceDeleteOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "RequestCascade" (optional.Bool) -
     * @param "RequestPropagationPolicy" (optional.String) -
     * @param "RequestAppNamespace" (optional.String) -
     * @param "RequestProject" (optional.String) -
     * @param "OptionsRemoveExistingFinalizers" (optional.Bool) -
@return ApplicationsApplicationResponse
*/

type ApplicationsApiAgentApplicationServiceDeleteOpts struct {
	AccountIdentifier               optional.String
	OrgIdentifier                   optional.String
	ProjectIdentifier               optional.String
	RequestCascade                  optional.Bool
	RequestPropagationPolicy        optional.String
	RequestAppNamespace             optional.String
	RequestProject                  optional.String
	OptionsRemoveExistingFinalizers optional.Bool
}

func (a *ApplicationsApiService) AgentApplicationServiceDelete(ctx context.Context, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServiceDeleteOpts) (ApplicationsApplicationResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestCascade.IsSet() {
		localVarQueryParams.Add("request.cascade", parameterToString(localVarOptionals.RequestCascade.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestPropagationPolicy.IsSet() {
		localVarQueryParams.Add("request.propagationPolicy", parameterToString(localVarOptionals.RequestPropagationPolicy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestAppNamespace.IsSet() {
		localVarQueryParams.Add("request.appNamespace", parameterToString(localVarOptionals.RequestAppNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestProject.IsSet() {
		localVarQueryParams.Add("request.project", parameterToString(localVarOptionals.RequestProject.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OptionsRemoveExistingFinalizers.IsSet() {
		localVarQueryParams.Add("options.removeExistingFinalizers", parameterToString(localVarOptionals.OptionsRemoveExistingFinalizers.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService DeleteResource deletes a single application resource
DeleteResource deletes a single application resource.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServiceDeleteResourceOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "RequestNamespace" (optional.String) -
     * @param "RequestResourceName" (optional.String) -
     * @param "RequestVersion" (optional.String) -
     * @param "RequestGroup" (optional.String) -
     * @param "RequestKind" (optional.String) -
     * @param "RequestForce" (optional.Bool) -
     * @param "RequestOrphan" (optional.Bool) -
     * @param "RequestAppNamespace" (optional.String) -
     * @param "RequestProject" (optional.String) -
@return ApplicationsApplicationResponse
*/

type ApplicationsApiAgentApplicationServiceDeleteResourceOpts struct {
	AccountIdentifier   optional.String
	OrgIdentifier       optional.String
	ProjectIdentifier   optional.String
	RequestNamespace    optional.String
	RequestResourceName optional.String
	RequestVersion      optional.String
	RequestGroup        optional.String
	RequestKind         optional.String
	RequestForce        optional.Bool
	RequestOrphan       optional.Bool
	RequestAppNamespace optional.String
	RequestProject      optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceDeleteResource(ctx context.Context, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServiceDeleteResourceOpts) (ApplicationsApplicationResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestNamespace.IsSet() {
		localVarQueryParams.Add("request.namespace", parameterToString(localVarOptionals.RequestNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestResourceName.IsSet() {
		localVarQueryParams.Add("request.resourceName", parameterToString(localVarOptionals.RequestResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestVersion.IsSet() {
		localVarQueryParams.Add("request.version", parameterToString(localVarOptionals.RequestVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestGroup.IsSet() {
		localVarQueryParams.Add("request.group", parameterToString(localVarOptionals.RequestGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestKind.IsSet() {
		localVarQueryParams.Add("request.kind", parameterToString(localVarOptionals.RequestKind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestForce.IsSet() {
		localVarQueryParams.Add("request.force", parameterToString(localVarOptionals.RequestForce.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestOrphan.IsSet() {
		localVarQueryParams.Add("request.orphan", parameterToString(localVarOptionals.RequestOrphan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestAppNamespace.IsSet() {
		localVarQueryParams.Add("request.appNamespace", parameterToString(localVarOptionals.RequestAppNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestProject.IsSet() {
		localVarQueryParams.Add("request.project", parameterToString(localVarOptionals.RequestProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Get returns an application by name
 Get returns an application by name
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName the application&#x27;s name
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceGetOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "QueryRefresh" (optional.String) -  forces application reconciliation if set to true.
     * @param "QueryProject" (optional.Interface of []string) -  the project names to restrict returned list applications.
     * @param "QueryResourceVersion" (optional.String) -  when specified with a watch call, shows changes that occur after that particular version of a resource.
     * @param "QuerySelector" (optional.String) -  the selector to to restrict returned list to applications only with matched labels.
     * @param "QueryRepo" (optional.String) -  the repoURL to restrict returned list applications.
     * @param "QueryAppNamespace" (optional.String) -
@return Servicev1Application
*/

type ApplicationsApiAgentApplicationServiceGetOpts struct {
	AccountIdentifier    optional.String
	OrgIdentifier        optional.String
	ProjectIdentifier    optional.String
	QueryRefresh         optional.String
	QueryProject         optional.Interface
	QueryResourceVersion optional.String
	QuerySelector        optional.String
	QueryRepo            optional.String
	QueryAppNamespace    optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceGet(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceGetOpts) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryRefresh.IsSet() {
		localVarQueryParams.Add("query.refresh", parameterToString(localVarOptionals.QueryRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		addQueryParam(localVarQueryParams, "query.project", localVarOptionals.QueryProject.Value(), "multi")
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceVersion.IsSet() {
		localVarQueryParams.Add("query.resourceVersion", parameterToString(localVarOptionals.QueryResourceVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySelector.IsSet() {
		localVarQueryParams.Add("query.selector", parameterToString(localVarOptionals.QuerySelector.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppNamespace.IsSet() {
		localVarQueryParams.Add("query.appNamespace", parameterToString(localVarOptionals.QueryAppNamespace.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Get returns sync windows of the application
GetApplicationSyncWindows returns sync windows of the application.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param agentIdentifier Agent identifier for entity.
  - @param queryName
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.

@return ApplicationsApplicationSyncWindowsResponse
*/
func (a *ApplicationsApiService) AgentApplicationServiceGetApplicationSyncWindows(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string) (ApplicationsApplicationSyncWindowsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationSyncWindowsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/syncwindows"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationSyncWindowsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService GetManifests returns application manifests
GetManifests returns application manifests.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceGetManifestsOpts - Optional Parameters:
     * @param "QueryRevision" (optional.String) -
@return RepositoriesManifestResponse
*/

type ApplicationsApiAgentApplicationServiceGetManifestsOpts struct {
	QueryRevision optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceGetManifests(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceGetManifestsOpts) (RepositoriesManifestResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesManifestResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/manifests"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryRevision.IsSet() {
		localVarQueryParams.Add("query.revision", parameterToString(localVarOptionals.QueryRevision.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesManifestResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService GetResource returns single application resource
GetResource returns single application resource.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServiceGetResourceOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
     * @param "RequestNamespace" (optional.String) -
     * @param "RequestResourceName" (optional.String) -
     * @param "RequestVersion" (optional.String) -
     * @param "RequestGroup" (optional.String) -
     * @param "RequestKind" (optional.String) -
     * @param "RequestAppNamespace" (optional.String) -
     * @param "RequestProject" (optional.String) -
@return ApplicationsApplicationResourceResponse
*/

type ApplicationsApiAgentApplicationServiceGetResourceOpts struct {
	AccountIdentifier   optional.String
	OrgIdentifier       optional.String
	ProjectIdentifier   optional.String
	RequestNamespace    optional.String
	RequestResourceName optional.String
	RequestVersion      optional.String
	RequestGroup        optional.String
	RequestKind         optional.String
	RequestAppNamespace optional.String
	RequestProject      optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceGetResource(ctx context.Context, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServiceGetResourceOpts) (ApplicationsApplicationResourceResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResourceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestNamespace.IsSet() {
		localVarQueryParams.Add("request.namespace", parameterToString(localVarOptionals.RequestNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestResourceName.IsSet() {
		localVarQueryParams.Add("request.resourceName", parameterToString(localVarOptionals.RequestResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestVersion.IsSet() {
		localVarQueryParams.Add("request.version", parameterToString(localVarOptionals.RequestVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestGroup.IsSet() {
		localVarQueryParams.Add("request.group", parameterToString(localVarOptionals.RequestGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestKind.IsSet() {
		localVarQueryParams.Add("request.kind", parameterToString(localVarOptionals.RequestKind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestAppNamespace.IsSet() {
		localVarQueryParams.Add("request.appNamespace", parameterToString(localVarOptionals.RequestAppNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestProject.IsSet() {
		localVarQueryParams.Add("request.project", parameterToString(localVarOptionals.RequestProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResourceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService List returns list of applications for a specific agent
List returns list of applications for a specific agent.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceListOpts - Optional Parameters:
     * @param "QueryName" (optional.String) -  the application&#x27;s name.
     * @param "QueryRefresh" (optional.String) -  forces application reconciliation if set to true.
     * @param "QueryProject" (optional.Interface of []string) -  the project names to restrict returned list applications.
     * @param "QueryResourceVersion" (optional.String) -  when specified with a watch call, shows changes that occur after that particular version of a resource.
     * @param "QuerySelector" (optional.String) -  the selector to to restrict returned list to applications only with matched labels.
     * @param "QueryRepo" (optional.String) -  the repoURL to restrict returned list applications.
     * @param "QueryAppNamespace" (optional.String) -
@return ApplicationsApplicationList
*/

type ApplicationsApiAgentApplicationServiceListOpts struct {
	QueryName            optional.String
	QueryRefresh         optional.String
	QueryProject         optional.Interface
	QueryResourceVersion optional.String
	QuerySelector        optional.String
	QueryRepo            optional.String
	QueryAppNamespace    optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceList(ctx context.Context, agentIdentifier string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceListOpts) (ApplicationsApplicationList, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryName.IsSet() {
		localVarQueryParams.Add("query.name", parameterToString(localVarOptionals.QueryName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRefresh.IsSet() {
		localVarQueryParams.Add("query.refresh", parameterToString(localVarOptionals.QueryRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		addQueryParam(localVarQueryParams, "query.project", localVarOptionals.QueryProject.Value(), "multi")
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceVersion.IsSet() {
		localVarQueryParams.Add("query.resourceVersion", parameterToString(localVarOptionals.QueryResourceVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySelector.IsSet() {
		localVarQueryParams.Add("query.selector", parameterToString(localVarOptionals.QuerySelector.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppNamespace.IsSet() {
		localVarQueryParams.Add("query.appNamespace", parameterToString(localVarOptionals.QueryAppNamespace.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService ListResourceActions returns list of resource actions
ListResourceActions returns list of resource actions.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceListResourceActionsOpts - Optional Parameters:
     * @param "RequestNamespace" (optional.String) -
     * @param "RequestResourceName" (optional.String) -
     * @param "RequestVersion" (optional.String) -
     * @param "RequestGroup" (optional.String) -
     * @param "RequestKind" (optional.String) -
     * @param "RequestAppNamespace" (optional.String) -
     * @param "RequestProject" (optional.String) -
@return ApplicationsResourceActionsListResponse
*/

type ApplicationsApiAgentApplicationServiceListResourceActionsOpts struct {
	RequestNamespace    optional.String
	RequestResourceName optional.String
	RequestVersion      optional.String
	RequestGroup        optional.String
	RequestKind         optional.String
	RequestAppNamespace optional.String
	RequestProject      optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceListResourceActions(ctx context.Context, agentIdentifier string, requestName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceListResourceActionsOpts) (ApplicationsResourceActionsListResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsResourceActionsListResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.RequestNamespace.IsSet() {
		localVarQueryParams.Add("request.namespace", parameterToString(localVarOptionals.RequestNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestResourceName.IsSet() {
		localVarQueryParams.Add("request.resourceName", parameterToString(localVarOptionals.RequestResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestVersion.IsSet() {
		localVarQueryParams.Add("request.version", parameterToString(localVarOptionals.RequestVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestGroup.IsSet() {
		localVarQueryParams.Add("request.group", parameterToString(localVarOptionals.RequestGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestKind.IsSet() {
		localVarQueryParams.Add("request.kind", parameterToString(localVarOptionals.RequestKind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestAppNamespace.IsSet() {
		localVarQueryParams.Add("request.appNamespace", parameterToString(localVarOptionals.RequestAppNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestProject.IsSet() {
		localVarQueryParams.Add("request.project", parameterToString(localVarOptionals.RequestProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsResourceActionsListResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService ListResourceEvents returns a list of event resources
ListResourceEvents returns list of event resources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceListResourceEventsOpts - Optional Parameters:
     * @param "QueryResourceNamespace" (optional.String) -
     * @param "QueryResourceName" (optional.String) -
     * @param "QueryResourceUID" (optional.String) -
     * @param "QueryAppNamespace" (optional.String) -
     * @param "QueryProject" (optional.String) -
@return V1EventList
*/

type ApplicationsApiAgentApplicationServiceListResourceEventsOpts struct {
	QueryResourceNamespace optional.String
	QueryResourceName      optional.String
	QueryResourceUID       optional.String
	QueryAppNamespace      optional.String
	QueryProject           optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceListResourceEvents(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceListResourceEventsOpts) (V1EventList, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue V1EventList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryResourceNamespace.IsSet() {
		localVarQueryParams.Add("query.resourceNamespace", parameterToString(localVarOptionals.QueryResourceNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceName.IsSet() {
		localVarQueryParams.Add("query.resourceName", parameterToString(localVarOptionals.QueryResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceUID.IsSet() {
		localVarQueryParams.Add("query.resourceUID", parameterToString(localVarOptionals.QueryResourceUID.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppNamespace.IsSet() {
		localVarQueryParams.Add("query.appNamespace", parameterToString(localVarOptionals.QueryAppNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v V1EventList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService ManagedResources returns list of managed resources
ManagedResources returns list of managed resources.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryApplicationName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceManagedResourcesOpts - Optional Parameters:
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryName" (optional.String) -
     * @param "QueryVersion" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryKind" (optional.String) -
     * @param "QueryAppNamespace" (optional.String) -
     * @param "QueryProject" (optional.String) -
@return ApplicationsManagedResourcesResponse
*/

type ApplicationsApiAgentApplicationServiceManagedResourcesOpts struct {
	QueryNamespace optional.String
	QueryName      optional.String
	QueryVersion   optional.String
	QueryGroup     optional.String
	QueryKind      optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceManagedResources(ctx context.Context, agentIdentifier string, queryApplicationName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceManagedResourcesOpts) (ApplicationsManagedResourcesResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsManagedResourcesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.applicationName}/managed-resources"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.applicationName"+"}", fmt.Sprintf("%v", queryApplicationName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryName.IsSet() {
		localVarQueryParams.Add("query.name", parameterToString(localVarOptionals.QueryName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryVersion.IsSet() {
		localVarQueryParams.Add("query.version", parameterToString(localVarOptionals.QueryVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsManagedResourcesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Patch patch an application
Patch applys a patches to an application.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName

@return Servicev1Application
*/
func (a *ApplicationsApiService) AgentApplicationServicePatch(ctx context.Context, body Servicev1ApplicationPatchRequest, agentIdentifier string, requestName string) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Patch")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService PatchResource patch single application resource
PatchResource patch single application resource.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServicePatchResourceOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
@return ApplicationsApplicationResourceResponse
*/

type ApplicationsApiAgentApplicationServicePatchResourceOpts struct {
	AccountIdentifier optional.String
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
}

func (a *ApplicationsApiService) AgentApplicationServicePatchResource(ctx context.Context, body ApplicationsApplicationResourcePatchRequest, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServicePatchResourceOpts) (ApplicationsApplicationResourceResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResourceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResourceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService PodLogs returns stream of log entries for the specified pod(s).
PodLogs returns stream of log entries for the specified pod(s).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param queryPodName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServicePodLogsOpts - Optional Parameters:
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryContainer" (optional.String) -
     * @param "QuerySinceSeconds" (optional.String) -
     * @param "QuerySinceTimeSeconds" (optional.String) -  Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @param "QuerySinceTimeNanos" (optional.Int32) -  Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     * @param "QueryTailLines" (optional.String) -
     * @param "QueryFollow" (optional.Bool) -
     * @param "QueryUntilTime" (optional.String) -
     * @param "QueryFilter" (optional.String) -
     * @param "QueryKind" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryResourceName" (optional.String) -
     * @param "QueryPrevious" (optional.Bool) -
     * @param "QueryAppNamespace" (optional.String) -
     * @param "QueryProject" (optional.String) -
@return StreamResultOfApplicationsLogEntry
*/

type ApplicationsApiAgentApplicationServicePodLogsOpts struct {
	QueryNamespace        optional.String
	QueryContainer        optional.String
	QuerySinceSeconds     optional.String
	QuerySinceTimeSeconds optional.String
	QuerySinceTimeNanos   optional.Int32
	QueryTailLines        optional.String
	QueryFollow           optional.Bool
	QueryUntilTime        optional.String
	QueryFilter           optional.String
	QueryKind             optional.String
	QueryGroup            optional.String
	QueryResourceName     optional.String
	QueryPrevious         optional.Bool
	QueryAppNamespace     optional.String
	QueryProject          optional.String
}

func (a *ApplicationsApiService) AgentApplicationServicePodLogs(ctx context.Context, agentIdentifier string, queryName string, queryPodName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServicePodLogsOpts) (StreamResultOfApplicationsLogEntry, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue StreamResultOfApplicationsLogEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/pods/{query.podName}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.podName"+"}", fmt.Sprintf("%v", queryPodName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryContainer.IsSet() {
		localVarQueryParams.Add("query.container", parameterToString(localVarOptionals.QueryContainer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceSeconds.IsSet() {
		localVarQueryParams.Add("query.sinceSeconds", parameterToString(localVarOptionals.QuerySinceSeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceTimeSeconds.IsSet() {
		localVarQueryParams.Add("query.sinceTime.seconds", parameterToString(localVarOptionals.QuerySinceTimeSeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceTimeNanos.IsSet() {
		localVarQueryParams.Add("query.sinceTime.nanos", parameterToString(localVarOptionals.QuerySinceTimeNanos.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryTailLines.IsSet() {
		localVarQueryParams.Add("query.tailLines", parameterToString(localVarOptionals.QueryTailLines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryFollow.IsSet() {
		localVarQueryParams.Add("query.follow", parameterToString(localVarOptionals.QueryFollow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryUntilTime.IsSet() {
		localVarQueryParams.Add("query.untilTime", parameterToString(localVarOptionals.QueryUntilTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryFilter.IsSet() {
		localVarQueryParams.Add("query.filter", parameterToString(localVarOptionals.QueryFilter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceName.IsSet() {
		localVarQueryParams.Add("query.resourceName", parameterToString(localVarOptionals.QueryResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryPrevious.IsSet() {
		localVarQueryParams.Add("query.previous", parameterToString(localVarOptionals.QueryPrevious.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppNamespace.IsSet() {
		localVarQueryParams.Add("query.appNamespace", parameterToString(localVarOptionals.QueryAppNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v StreamResultOfApplicationsLogEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService PodLogs returns stream of log entries for the specified pod(s).
PodLogs returns stream of log entries for the specified pod(s).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServicePodLogs2Opts - Optional Parameters:
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryPodName" (optional.String) -
     * @param "QueryContainer" (optional.String) -
     * @param "QuerySinceSeconds" (optional.String) -
     * @param "QuerySinceTimeSeconds" (optional.String) -  Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @param "QuerySinceTimeNanos" (optional.Int32) -  Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     * @param "QueryTailLines" (optional.String) -
     * @param "QueryFollow" (optional.Bool) -
     * @param "QueryUntilTime" (optional.String) -
     * @param "QueryFilter" (optional.String) -
     * @param "QueryKind" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryResourceName" (optional.String) -
     * @param "QueryPrevious" (optional.Bool) -
     * @param "QueryAppNamespace" (optional.String) -
     * @param "QueryProject" (optional.String) -
@return StreamResultOfApplicationsLogEntry
*/

type ApplicationsApiAgentApplicationServicePodLogs2Opts struct {
	QueryNamespace        optional.String
	QueryPodName          optional.String
	QueryContainer        optional.String
	QuerySinceSeconds     optional.String
	QuerySinceTimeSeconds optional.String
	QuerySinceTimeNanos   optional.Int32
	QueryTailLines        optional.String
	QueryFollow           optional.Bool
	QueryUntilTime        optional.String
	QueryFilter           optional.String
	QueryKind             optional.String
	QueryGroup            optional.String
	QueryResourceName     optional.String
	QueryPrevious         optional.Bool
	QueryAppNamespace     optional.String
	QueryProject          optional.String
}

func (a *ApplicationsApiService) AgentApplicationServicePodLogs2(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServicePodLogs2Opts) (StreamResultOfApplicationsLogEntry, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue StreamResultOfApplicationsLogEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryPodName.IsSet() {
		localVarQueryParams.Add("query.podName", parameterToString(localVarOptionals.QueryPodName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryContainer.IsSet() {
		localVarQueryParams.Add("query.container", parameterToString(localVarOptionals.QueryContainer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceSeconds.IsSet() {
		localVarQueryParams.Add("query.sinceSeconds", parameterToString(localVarOptionals.QuerySinceSeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceTimeSeconds.IsSet() {
		localVarQueryParams.Add("query.sinceTime.seconds", parameterToString(localVarOptionals.QuerySinceTimeSeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySinceTimeNanos.IsSet() {
		localVarQueryParams.Add("query.sinceTime.nanos", parameterToString(localVarOptionals.QuerySinceTimeNanos.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryTailLines.IsSet() {
		localVarQueryParams.Add("query.tailLines", parameterToString(localVarOptionals.QueryTailLines.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryFollow.IsSet() {
		localVarQueryParams.Add("query.follow", parameterToString(localVarOptionals.QueryFollow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryUntilTime.IsSet() {
		localVarQueryParams.Add("query.untilTime", parameterToString(localVarOptionals.QueryUntilTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryFilter.IsSet() {
		localVarQueryParams.Add("query.filter", parameterToString(localVarOptionals.QueryFilter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceName.IsSet() {
		localVarQueryParams.Add("query.resourceName", parameterToString(localVarOptionals.QueryResourceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryPrevious.IsSet() {
		localVarQueryParams.Add("query.previous", parameterToString(localVarOptionals.QueryPrevious.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppNamespace.IsSet() {
		localVarQueryParams.Add("query.appNamespace", parameterToString(localVarOptionals.QueryAppNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v StreamResultOfApplicationsLogEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService ResourceTree returns resource tree
ResourceTree returns resource tree.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceResourceTreeOpts - Optional Parameters:
     * @param "QueryApplicationName" (optional.String) -
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryVersion" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryKind" (optional.String) -
     * @param "QueryAppNamespace" (optional.String) -
     * @param "QueryProject" (optional.String) -
@return ApplicationsApplicationTree
*/

type ApplicationsApiAgentApplicationServiceResourceTreeOpts struct {
	QueryApplicationName optional.String
	QueryNamespace       optional.String
	QueryVersion         optional.String
	QueryGroup           optional.String
	QueryKind            optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceResourceTree(ctx context.Context, agentIdentifier string, queryName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceResourceTreeOpts) (ApplicationsApplicationTree, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationTree
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/resource-tree"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryApplicationName.IsSet() {
		localVarQueryParams.Add("query.applicationName", parameterToString(localVarOptionals.QueryApplicationName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryVersion.IsSet() {
		localVarQueryParams.Add("query.version", parameterToString(localVarOptionals.QueryVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationTree
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Get the meta-data (author, date, tags, message) for a specific revision of the application
RevisionMetadata returns metadata for a specific revision of the application.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param agentIdentifier Agent identifier for entity.
  - @param queryName the application&#x27;s name
  - @param queryRevision the revision of the app
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.

@return RepositoriesRevisionMetadata
*/
func (a *ApplicationsApiService) AgentApplicationServiceRevisionMetadata(ctx context.Context, agentIdentifier string, queryName string, queryRevision string, accountIdentifier string, orgIdentifier string, projectIdentifier string) (RepositoriesRevisionMetadata, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue RepositoriesRevisionMetadata
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{query.name}/revisions/{query.revision}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.name"+"}", fmt.Sprintf("%v", queryName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.revision"+"}", fmt.Sprintf("%v", queryRevision), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v RepositoriesRevisionMetadata
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Rollback syncs an application to its target state Harness Event type (rollback)
Rollback syncs an application to its target state Harness Event type (rollback).
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName

@return Servicev1Application
*/
func (a *ApplicationsApiService) AgentApplicationServiceRollback(ctx context.Context, body ApplicationsApplicationRollbackRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, agentIdentifier string, requestName string) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService RunResourceAction run resource action
RunResourceAction run resource action.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param agentIdentifier Agent identifier for entity.
 * @param requestName
 * @param optional nil or *ApplicationsApiAgentApplicationServiceRunResourceActionOpts - Optional Parameters:
     * @param "AccountIdentifier" (optional.String) -  Account Identifier for the Entity.
     * @param "OrgIdentifier" (optional.String) -  Organization Identifier for the Entity.
     * @param "ProjectIdentifier" (optional.String) -  Project Identifier for the Entity.
@return ApplicationsApplicationResponse
*/

type ApplicationsApiAgentApplicationServiceRunResourceActionOpts struct {
	AccountIdentifier optional.String
	OrgIdentifier     optional.String
	ProjectIdentifier optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceRunResourceAction(ctx context.Context, body ApplicationsResourceActionRunRequest, agentIdentifier string, requestName string, localVarOptionals *ApplicationsApiAgentApplicationServiceRunResourceActionOpts) (ApplicationsApplicationResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/resource/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AccountIdentifier.IsSet() {
		localVarQueryParams.Add("accountIdentifier", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
		localVarQueryParams.Add("routingId", parameterToString(localVarOptionals.AccountIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgIdentifier.IsSet() {
		localVarQueryParams.Add("orgIdentifier", parameterToString(localVarOptionals.OrgIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectIdentifier.IsSet() {
		localVarQueryParams.Add("projectIdentifier", parameterToString(localVarOptionals.ProjectIdentifier.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Sync syncs an application to its target state Harness Event type (deploy)
Delete deletes an application.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName

@return Servicev1Application
*/
func (a *ApplicationsApiService) AgentApplicationServiceSync(ctx context.Context, body ApplicationsApplicationSyncRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, agentIdentifier string, requestName string) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/sync"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService TerminateOperation terminates the currently running operation
TerminateOperation terminates the currently running operation.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.

@return ApplicationsOperationTerminateResponse
*/
func (a *ApplicationsApiService) AgentApplicationServiceTerminateOperation(ctx context.Context, agentIdentifier string, requestName string, accountIdentifier string, orgIdentifier string, projectIdentifier string) (ApplicationsOperationTerminateResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsOperationTerminateResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/operation"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsOperationTerminateResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Update updates an application
Update updates an application.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param agentIdentifier Agent identifier for entity.
 * @param requestApplicationMetadataName Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
 * @param optional nil or *ApplicationsApiAgentApplicationServiceUpdateOpts - Optional Parameters:
     * @param "ClusterIdentifier" (optional.String) -
     * @param "RepoIdentifier" (optional.String) -
     * @param "SkipRepoValidation" (optional.Bool) -
     * @param "RepoIdentifiers" (optional.Interface of []string) -
@return Servicev1Application
*/

type ApplicationsApiAgentApplicationServiceUpdateOpts struct {
	ClusterIdentifier  optional.String
	RepoIdentifier     optional.String
	SkipRepoValidation optional.Bool
	RepoIdentifiers    optional.Interface
}

func (a *ApplicationsApiService) AgentApplicationServiceUpdate(ctx context.Context, body ApplicationsApplicationUpdateRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, agentIdentifier string, requestApplicationMetadataName string, localVarOptionals *ApplicationsApiAgentApplicationServiceUpdateOpts) (Servicev1Application, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Servicev1Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.application.metadata.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.application.metadata.name"+"}", fmt.Sprintf("%v", requestApplicationMetadataName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.ClusterIdentifier.IsSet() {
		localVarQueryParams.Add("clusterIdentifier", parameterToString(localVarOptionals.ClusterIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifier.IsSet() {
		localVarQueryParams.Add("repoIdentifier", parameterToString(localVarOptionals.RepoIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SkipRepoValidation.IsSet() {
		localVarQueryParams.Add("skipRepoValidation", parameterToString(localVarOptionals.SkipRepoValidation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepoIdentifiers.IsSet() {
		// cast RepoIdentifiers to array of string
		ids := localVarOptionals.RepoIdentifiers.Value().([]string)
		for _, id := range ids {
			localVarQueryParams.Add("repoIdentifiers", parameterToString(id, ""))
		}
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode >= 400 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}

		if localVarHttpResponse.StatusCode == 200 {
			var v Servicev1Application
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService UpdateSpec updates an application spec
UpdateSpec updates an application spec.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body
  - @param accountIdentifier Account Identifier for the Entity.
  - @param orgIdentifier Organization Identifier for the Entity.
  - @param projectIdentifier Project Identifier for the Entity.
  - @param agentIdentifier Agent identifier for entity.
  - @param requestName

@return ApplicationsApplicationSpec
*/
func (a *ApplicationsApiService) AgentApplicationServiceUpdateSpec(ctx context.Context, body ApplicationsApplicationUpdateSpecRequest, accountIdentifier string, orgIdentifier string, projectIdentifier string, agentIdentifier string, requestName string) (ApplicationsApplicationSpec, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue ApplicationsApplicationSpec
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/applications/{request.name}/spec"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"request.name"+"}", fmt.Sprintf("%v", requestName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ApplicationsApplicationSpec
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Watch returns stream of application change events
Watch returns stream of application change events.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param queryName the application&#x27;s name.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceWatchOpts - Optional Parameters:
     * @param "QueryRefresh" (optional.String) -  forces application reconciliation if set to true.
     * @param "QueryProject" (optional.Interface of []string) -  the project names to restrict returned list applications.
     * @param "QueryResourceVersion" (optional.String) -  when specified with a watch call, shows changes that occur after that particular version of a resource.
     * @param "QuerySelector" (optional.String) -  the selector to to restrict returned list to applications only with matched labels.
     * @param "QueryRepo" (optional.String) -  the repoURL to restrict returned list applications.
     * @param "QueryAppNamespace" (optional.String) -
@return StreamResultOfApplicationsApplicationWatchEvent
*/

type ApplicationsApiAgentApplicationServiceWatchOpts struct {
	QueryRefresh         optional.String
	QueryProject         optional.Interface
	QueryResourceVersion optional.String
	QuerySelector        optional.String
	QueryRepo            optional.String
	QueryAppNamespace    optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceWatch(ctx context.Context, agentIdentifier string, accountIdentifier string, orgIdentifier string, projectIdentifier string, queryName string, localVarOptionals *ApplicationsApiAgentApplicationServiceWatchOpts) (StreamResultOfApplicationsApplicationWatchEvent, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue StreamResultOfApplicationsApplicationWatchEvent
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/stream/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	localVarQueryParams.Add("query.name", parameterToString(queryName, ""))
	if localVarOptionals != nil && localVarOptionals.QueryRefresh.IsSet() {
		localVarQueryParams.Add("query.refresh", parameterToString(localVarOptionals.QueryRefresh.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		addQueryParam(localVarQueryParams, "query.project", localVarOptionals.QueryProject.Value(), "multi")
	}
	if localVarOptionals != nil && localVarOptionals.QueryResourceVersion.IsSet() {
		localVarQueryParams.Add("query.resourceVersion", parameterToString(localVarOptionals.QueryResourceVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuerySelector.IsSet() {
		localVarQueryParams.Add("query.selector", parameterToString(localVarOptionals.QuerySelector.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryRepo.IsSet() {
		localVarQueryParams.Add("query.repo", parameterToString(localVarOptionals.QueryRepo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppNamespace.IsSet() {
		localVarQueryParams.Add("query.appNamespace", parameterToString(localVarOptionals.QueryAppNamespace.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v StreamResultOfApplicationsApplicationWatchEvent
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService WatchResourceTree returns stream of application resource tree
WatchResourceTree returns stream of application resource tree.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param agentIdentifier Agent identifier for entity.
 * @param queryApplicationName
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiAgentApplicationServiceWatchResourceTreeOpts - Optional Parameters:
     * @param "QueryNamespace" (optional.String) -
     * @param "QueryName" (optional.String) -
     * @param "QueryVersion" (optional.String) -
     * @param "QueryGroup" (optional.String) -
     * @param "QueryKind" (optional.String) -
     * @param "QueryAppNamespace" (optional.String) -
     * @param "QueryProject" (optional.String) -
@return StreamResultOfApplicationsApplicationTree
*/

type ApplicationsApiAgentApplicationServiceWatchResourceTreeOpts struct {
	QueryNamespace    optional.String
	QueryName         optional.String
	QueryVersion      optional.String
	QueryGroup        optional.String
	QueryKind         optional.String
	QueryAppNamespace optional.String
	QueryProject      optional.String
}

func (a *ApplicationsApiService) AgentApplicationServiceWatchResourceTree(ctx context.Context, agentIdentifier string, queryApplicationName string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiAgentApplicationServiceWatchResourceTreeOpts) (StreamResultOfApplicationsApplicationTree, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue StreamResultOfApplicationsApplicationTree
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/agents/{agentIdentifier}/stream/applications/{query.applicationName}/resource-tree"
	localVarPath = strings.Replace(localVarPath, "{"+"agentIdentifier"+"}", fmt.Sprintf("%v", agentIdentifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"query.applicationName"+"}", fmt.Sprintf("%v", queryApplicationName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.QueryNamespace.IsSet() {
		localVarQueryParams.Add("query.namespace", parameterToString(localVarOptionals.QueryNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryName.IsSet() {
		localVarQueryParams.Add("query.name", parameterToString(localVarOptionals.QueryName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryVersion.IsSet() {
		localVarQueryParams.Add("query.version", parameterToString(localVarOptionals.QueryVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryGroup.IsSet() {
		localVarQueryParams.Add("query.group", parameterToString(localVarOptionals.QueryGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryKind.IsSet() {
		localVarQueryParams.Add("query.kind", parameterToString(localVarOptionals.QueryKind.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryAppNamespace.IsSet() {
		localVarQueryParams.Add("query.appNamespace", parameterToString(localVarOptionals.QueryAppNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryProject.IsSet() {
		localVarQueryParams.Add("query.project", parameterToString(localVarOptionals.QueryProject.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v StreamResultOfApplicationsApplicationTree
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService Checks whether an app with the given name exists
Checks whether an app with the given name exists
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name
 * @param accountIdentifier Account Identifier for the Entity.
 * @param orgIdentifier Organization Identifier for the Entity.
 * @param projectIdentifier Project Identifier for the Entity.
 * @param optional nil or *ApplicationsApiApplicationServiceExistsOpts - Optional Parameters:
     * @param "AgentIdentifier" (optional.String) -  Agent identifier for entity.
@return bool
*/

type ApplicationsApiApplicationServiceExistsOpts struct {
	AgentIdentifier optional.String
}

func (a *ApplicationsApiService) ApplicationServiceExists(ctx context.Context, name string, accountIdentifier string, orgIdentifier string, projectIdentifier string, localVarOptionals *ApplicationsApiApplicationServiceExistsOpts) (bool, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue bool
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/applications/{name}/exists"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("accountIdentifier", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("routingId", parameterToString(accountIdentifier, ""))
	localVarQueryParams.Add("orgIdentifier", parameterToString(orgIdentifier, ""))
	localVarQueryParams.Add("projectIdentifier", parameterToString(projectIdentifier, ""))
	if localVarOptionals != nil && localVarOptionals.AgentIdentifier.IsSet() {
		localVarQueryParams.Add("agentIdentifier", parameterToString(localVarOptionals.AgentIdentifier.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v bool
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ApplicationsApiService List returns list of application sync status
List returns list of application sync status
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body

@return V1ApplicationSyncStatuslist
*/
func (a *ApplicationsApiService) ApplicationServiceListAppSync(ctx context.Context, body V1ApplicationSyncStatusQuery) (V1ApplicationSyncStatuslist, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue V1ApplicationSyncStatuslist
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/gitops/api/v1/applications/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-api-key"] = key

		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v V1ApplicationSyncStatuslist
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v GatewayruntimeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
